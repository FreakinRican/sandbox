* establish commands
  * init
    * init /path/to/sandbox
  * list?
    * list ruby
    * list rubygems
  * config
    * config source.ruby add
    * config source.ruby remove
    * config source.ruby default
    * config source.rubygems add
    * config source.rubygems remove
    * config source.rubygems default
    * config default.install rubygems
    * config default.ruby
    * config default.rubygems
  * cache
    * cache purge
    * cache list

* build procedures ( can I create entire structure in tmp and build, moving when done? )
  * create sandbox directory
      /path/to/sandbox/
      /path/to/sandbox/etc
      /path/to/sandbox/bin
  * install ruby
    * build ruby ( possibly need to change build values ( like bleak house? ) )
      * locate ruby source code
        * IF check cache for extracted ruby in cache-extract
            make clean
        * ELSE IF check cache for ruby tarball and extract to cache-extract
        * ELSE download ruby to cache and extract to cache-extract
      * configure
          ./configure --prefix /new/sandbox/directory
      * build
          make
      * install
          make install
  * install rubygems
    * build with new ruby
      * locate rubygems source code
        * IF check cache for extracted rubygems in cache-extract
        * ELSE IF check cache for rubygems tarball and extract to cache-extract
        * ELSE download ruby to cachegems and extract to cache-extract
      * unset environment variables
      * install
          /path/to/new/ruby setup.rb
    * build with system ruby
      * locate rubygems source code
        * IF check cache for extracted rubygems in cache-extract
        * ELSE IF check cache for rubygems tarball and extract to cache-extract
        * ELSE download ruby to cachegems and extract to cache-extract
      * set environment variables
          export GEM_HOME=$SANDBOX/rubygems
          export GEM_PATH=$GEM_HOME
          export RUBYLIB=$SANDBOX/lib/rubyinstall/lib
      * backup user's .gemrc file
          cp ~/.gemrc /tmp/.gemrc.orig
      * install rubygems
          /path/to/system/ruby setup.rb --prefix=$SANDBOX/lib/rubyinstall
      * restore .gemrc file
          cp /tmp/.gemrc.orig ~/.gemrc
      * maybe symlink the binary?
          ln -s $SANDBOX/lib/rubyinstall/bin $SANDBOX/bin


  
  download cache
     ~/.sandbox/sources/ruby
         stored by version/patchlevel
     ~/.sandbox/sources/rubygems
         stored by version
  
  global config
     hash of download urls for ruby and rubygems
     one is selected from each by default
     ftp://ftp.ruby-lang.org/pub/ruby/1.8/ruby-1.8.6-p287.tar.gz
     ftp://ftp.ruby-lang.org/pub/ruby/1.8/ruby-1.8.6-p287.tar.bz2
     
     # inspiration from deprec, rubygems, bleak_house
     
     DEPREC_TEMPLATES_BASE = File.join(File.dirname(__FILE__), 'templates')
     
     SRC_PACKAGES[:ruby] = {
       :filename => 'ruby-1.8.6-p287.tar.gz',
       :md5sum => "f6cd51001534ced5375339707a757556  ruby-1.8.6-p287.tar.gz",
       :dir => 'ruby-1.8.6-p287',
       :url => "ftp://ftp.ruby-lang.org/pub/ruby/1.8/ruby-1.8.6-p287.tar.gz",
       :unpack => "tar zxf ruby-1.8.6-p287.tar.gz;",
       :configure => %w(
       ./configure
       --with-readline-dir=/usr/local
       ;
       ).reject{|arg| arg.match '#'}.join(' '),
       :make => 'make;',
       :install => 'make install;'
     }
     SRC_PACKAGES[:rubygems] = {
       :filename => 'rubygems-1.3.1.tgz',
       :md5sum => "a04ee6f6897077c5b75f5fd1e134c5a9  rubygems-1.3.1.tgz",
       :dir => 'rubygems-1.3.1',
       :url => "http://rubyforge.org/frs/download.php/45905/rubygems-1.3.1.tgz",
       :unpack => "tar zxf rubygems-1.3.1.tgz;",
       :configure => "",
       :make => "",
       :install => 'ruby setup.rb;'
     }
  
  user config
     ~/.sandbox/config
     change install version choices
  
  get ruby / rubygems
     goes into download cache
  
  build ruby and rubygems
     built in /tmp/?
     ruby: --prefix new/sandbox/directory
     rubygems: new/sandbox/directory/bin/ruby setup.rb
     installed into new/sandbox/directory
  
  build only rubygems
     need to set RUBYLIB and GEM_HOME
  
  activate / deactivate script
     2 versions
         a) for ruby/rubygems install (basically sets path)
         b) for rubygems only install (set RUBYLIB, GEM_HOME and PATH)


= inspiration

based on codeforpeople's rubyforge:
require 'enumerator'
require 'fileutils'
require 'yaml'
require 'open-uri'

require 'pp'

# File lib/rubyforge.rb, line 106
def scrape_project(project, criteria={})
  max = criteria[ 'max' ] ? criteria[ 'max' ] : nil
  min = criteria[ 'min' ] ? criteria[ 'min' ] : nil
  data = {
    project => Hash.new { |h,k| h[k] = {} },
  }
  html = URI.parse("http://rubyforge.org/projects/#{project}/index.html").read
  group_id = html[/(frs|tracker|mail)\/\?group_id=\d+/][/\d+/].to_i
  html = URI.parse("http://rubyforge.org/frs/?group_id=#{group_id}").read
  
  html.scan(/download.php[^"]+">[^<]+/).each do |s|
    next unless s =~ /(tar|gz|bz2|tgz|zip)$/
    if s =~ /download.php\/(\d+)\/(#{project}[^"]+)">([^<]+)/
      version = $3
      file = $2
      stamp = $1
      dl = "#{stamp}/#{file}"
      parts = version.split('.')
      parts.pop while [ 'tar','gz','bz2','tgz','zip' ].include? parts.last
      name = parts.join('.')
      if name =~ /^#{project}-(\d+)\.(\d+)\.(\d+)/
        major, minor, tiny = $1, $2, $3
        next if min and name < "#{project}-#{min}" 
        next if max and name > "#{project}-#{max}"
        # data[ project ][ name ] ||= Hash.new { |h,k| h[k] = {} }
        # data[ project ][ name ][ version ] = "http://rubyforge.org/frs/download.php/#{dl}"
        data[ project ][ "#{major}.#{minor}.#{tiny}" ] ||= Hash.new { |h,k| h[k] = {} }
        data[ project ][ "#{major}.#{minor}.#{tiny}" ][ stamp ] ||= Hash.new { |h,k| h[k] = {} }
        data[ project ][ "#{major}.#{minor}.#{tiny}" ][ stamp ][ name ] ||= Hash.new { |h,k| h[k] = {} }
        data[ project ][ "#{major}.#{minor}.#{tiny}" ][ stamp ][ name ][ version ] = "http://rubyforge.org/frs/download.php/#{dl}"
      end
    end
  end
  
  data[ project ].keys.sort.each do |key|
    out = { key => data[project][key].keys.sort }
    pp out
  end
  data
end


